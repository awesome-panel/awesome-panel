[
  {
    "objectID": "resources/stumpy/index.html",
    "href": "resources/stumpy/index.html",
    "title": "Stumpy",
    "section": "",
    "text": "STUMPY is a powerful and scalable Python library identifies repeating patterns in your timeseries. It does this by efficiently computing something called a matrix profile.\nThe app is a Bokeh app wrapped in a nice Panel template."
  },
  {
    "objectID": "resources/stumpy/index.html#introduction",
    "href": "resources/stumpy/index.html#introduction",
    "title": "Stumpy",
    "section": "",
    "text": "STUMPY is a powerful and scalable Python library identifies repeating patterns in your timeseries. It does this by efficiently computing something called a matrix profile.\nThe app is a Bokeh app wrapped in a nice Panel template."
  },
  {
    "objectID": "resources/stumpy/index.html#app",
    "href": "resources/stumpy/index.html#app",
    "title": "Stumpy",
    "section": "App",
    "text": "App\nThis app runs entirely in the browser via Pyodide and panel convert.\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/stumpy/index.html#code",
    "href": "resources/stumpy/index.html#code",
    "title": "Stumpy",
    "section": "Code",
    "text": "Code\n\n\nShow\n\n#!/usr/bin/env python\n\nimport panel as pn\nimport pandas as pd\n\nfrom bokeh.plotting import figure\nfrom bokeh.layouts import layout\nfrom bokeh.models import (\n    ColumnDataSource,\n    Range1d,\n    Slider,\n    Button,\n    TextInput,\n    LabelSet,\n    Circle,\n    Div,\n)\n\nclass StumpyBokehDashboard:\n    def __init__(self):\n        self.sizing_mode = \"stretch_both\"\n        self.window = 0\n        self.m = None\n\n        self.df = None\n        self.ts_cds = None\n        self.quad_cds = None\n        self.pattern_match_cds = None\n        self.dist_cds = None\n        self.circle_cds = None\n\n        self.ts_plot = None\n        self.mp_plot = None\n        self.pm_plot = None\n        self.logo_div = None\n        self.heroku_div = None\n\n        self.slider = None\n        self.play_btn = None\n        self.txt_inp = None\n        self.pattern_btn = None\n        self.match_btn = None\n        self.reset_btn = None\n        self.idx = None\n        self.min_distance_idx = None\n\n        self.animation = pn.state.add_periodic_callback(\n            self.update_animate, 50, start=False\n        )\n\n    def get_df_from_file(self):\n        raw_df = pd.read_csv(\n            \"https://raw.githubusercontent.com/seanlaw/stumpy-live-demo/master/raw.csv\"\n        )\n\n        mp_df = pd.read_csv(\n            \"https://raw.githubusercontent.com/seanlaw/stumpy-live-demo/master/matrix_profile.csv\"\n        )\n\n        self.window = raw_df.shape[0] - mp_df.shape[0] + 1\n        self.m = raw_df.shape[0] - mp_df.shape[0] + 1\n        self.min_distance_idx = mp_df[\"distance\"].argmin()\n\n        df = pd.merge(raw_df, mp_df, left_index=True, how=\"left\", right_index=True)\n\n        return df.reset_index()\n\n    def get_ts_dict(self, df):\n        return self.df.to_dict(orient=\"list\")\n\n    def get_circle_dict(self, df):\n        return self.df[[\"index\", \"y\"]].to_dict(orient=\"list\")\n\n    def get_quad_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df.loc[pattern_idx, \"idx\"].astype(int)\n        quad_dict = dict(\n            pattern_left=[pattern_idx],\n            pattern_right=[pattern_idx + self.window - 1],\n            pattern_top=[max(df[\"y\"])],\n            pattern_bottom=[0],\n            match_left=[match_idx],\n            match_right=[match_idx + self.window - 1],\n            match_top=[max(df[\"y\"])],\n            match_bottom=[0],\n            vert_line_left=[pattern_idx - 5],\n            vert_line_right=[pattern_idx + 5],\n            vert_line_top=[max(df[\"distance\"])],\n            vert_line_bottom=[0],\n            hori_line_left=[0],\n            hori_line_right=[max(df[\"index\"])],\n            hori_line_top=[df.loc[pattern_idx, \"distance\"] - 0.01],\n            hori_line_bottom=[df.loc[pattern_idx, \"distance\"] + 0.01],\n        )\n        return quad_dict\n\n    def get_custom_quad_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df.loc[pattern_idx, \"idx\"].astype(int)\n        quad_dict = dict(\n            pattern_left=[pattern_idx],\n            pattern_right=[pattern_idx + self.window - 1],\n            pattern_top=[max(df[\"y\"])],\n            pattern_bottom=[0],\n            match_left=[match_idx],\n            match_right=[match_idx + self.window - 1],\n            match_top=[max(df[\"y\"])],\n            match_bottom=[0],\n            vert_line_left=[match_idx - 5],\n            vert_line_right=[match_idx + 5],\n            vert_line_top=[max(df[\"distance\"])],\n            vert_line_bottom=[0],\n            hori_line_left=[0],\n            hori_line_right=[max(df[\"index\"])],\n            hori_line_top=[df.loc[match_idx, \"distance\"] - 0.01],\n            hori_line_bottom=[df.loc[match_idx, \"distance\"] + 0.01],\n        )\n        return quad_dict\n\n    def get_pattern_match_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df[\"idx\"].loc[pattern_idx].astype(int)\n        pattern_match_dict = dict(\n            index=list(range(self.window)),\n            pattern=df[\"y\"].loc[pattern_idx : pattern_idx + self.window - 1],\n            match=df[\"y\"].loc[match_idx : match_idx + self.window - 1],\n        )\n\n        return pattern_match_dict\n\n    def get_ts_plot(self, color=\"black\"):\n        \"\"\"\n        Time Series Plot\n        \"\"\"\n        ts_plot = figure(\n            toolbar_location=\"above\",\n            sizing_mode=self.sizing_mode,\n            title=\"Raw Time Series or Sequence\",\n            tools=[\"reset\"],\n        )\n        q = ts_plot.quad(\n            \"pattern_left\",\n            \"pattern_right\",\n            \"pattern_top\",\n            \"pattern_bottom\",\n            source=self.quad_cds,\n            name=\"pattern_quad\",\n            color=\"#54b847\",\n        )\n        q.visible = False\n        q = ts_plot.quad(\n            \"match_left\",\n            \"match_right\",\n            \"match_top\",\n            \"match_bottom\",\n            source=self.quad_cds,\n            name=\"match_quad\",\n            color=\"#696969\",\n            alpha=0.5,\n        )\n        q.visible = False\n        l = ts_plot.line(x=\"index\", y=\"y\", source=self.ts_cds, color=color)\n        ts_plot.x_range = Range1d(\n            0, max(self.df[\"index\"]), bounds=(0, max(self.df[\"x\"]))\n        )\n        ts_plot.y_range = Range1d(0, max(self.df[\"y\"]), bounds=(0, max(self.df[\"y\"])))\n\n        c = ts_plot.circle(\n            x=\"index\", y=\"y\", source=self.circle_cds, size=0, line_color=\"white\"\n        )\n        c.selection_glyph = Circle(line_color=\"white\")\n        c.nonselection_glyph = Circle(line_color=\"white\")\n\n        return ts_plot\n\n    def get_dist_dict(self, df, pattern_idx=0):\n        dist = df[\"distance\"]\n        max_dist = dist.max()\n        min_dist = dist.min()\n        x_offset = self.df.shape[0] - self.window / 2\n        y_offset = max_dist / 2\n        distance = dist.loc[pattern_idx]\n        text = distance.round(1).astype(str)\n        gauge_dict = dict(x=[0 + x_offset], y=[0 + y_offset], text=[text])\n\n        return gauge_dict\n\n    def get_mp_plot(self):\n        \"\"\"\n        Matrix Profile Plot\n        \"\"\"\n        mp_plot = figure(\n            x_range=self.ts_plot.x_range,\n            toolbar_location=None,\n            sizing_mode=self.sizing_mode,\n            title=\"Matrix Profile (All Minimum Distances)\",\n        )\n        q = mp_plot.quad(\n            \"vert_line_left\",\n            \"vert_line_right\",\n            \"vert_line_top\",\n            \"vert_line_bottom\",\n            source=self.quad_cds,\n            name=\"pattern_start\",\n            color=\"#54b847\",\n        )\n        q.visible = False\n        q = mp_plot.quad(\n            \"hori_line_left\",\n            \"hori_line_right\",\n            \"hori_line_top\",\n            \"hori_line_bottom\",\n            source=self.quad_cds,\n            name=\"match_dist\",\n            color=\"#696969\",\n            alpha=0.5,\n        )\n        q.visible = False\n        mp_plot.line(x=\"index\", y=\"distance\", source=self.ts_cds, color=\"black\")\n        # mp_plot.x_range = Range1d(0, self.df.shape[0]-self.window+1, bounds=(0, self.df.shape[0]-self.window+1))\n        mp_plot.x_range = Range1d(\n            0, self.df.shape[0] + 1, bounds=(0, self.df.shape[0] + 1)\n        )\n        mp_plot.y_range = Range1d(\n            0, max(self.df[\"distance\"]), bounds=(0, max(self.df[\"distance\"]))\n        )\n\n        label = LabelSet(\n            x=\"x\",\n            y=\"y\",\n            text=\"text\",\n            source=self.dist_cds,\n            text_align=\"center\",\n            name=\"gauge_label\",\n            text_color=\"black\",\n            text_font_size=\"30pt\",\n        )\n        mp_plot.add_layout(label)\n\n        return mp_plot\n\n    def get_pm_plot(self):\n        \"\"\"\n        Pattern-Match Plot\n        \"\"\"\n        pm_plot = figure(\n            toolbar_location=None,\n            sizing_mode=self.sizing_mode,\n            title=\"Pattern Match Overlay\",\n        )\n        l = pm_plot.line(\n            \"index\",\n            \"pattern\",\n            source=self.pattern_match_cds,\n            name=\"pattern_line\",\n            color=\"#54b847\",\n            line_width=2,\n        )\n        l.visible = False\n        l = pm_plot.line(\n            \"index\",\n            \"match\",\n            source=self.pattern_match_cds,\n            name=\"match_line\",\n            color=\"#696969\",\n            alpha=0.5,\n            line_width=2,\n        )\n        l.visible = False\n\n        return pm_plot\n\n    def get_logo_div(self):\n        \"\"\"\n        STUMPY logo\n        \"\"\"\n\n        logo_div = Div(\n            text=\"&lt;a href='https://stumpy.readthedocs.io/en/latest/'&gt;&lt;img src='https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/images/stumpy_logo_small.png' style='width:100%'&gt;&lt;/a&gt;\", sizing_mode=\"stretch_width\"\n        )\n\n        return logo_div\n\n    def get_heroku_div(self):\n        \"\"\"\n        STUMPY Heroku App Link\n        \"\"\"\n\n        heroku_div = Div(text=\"http://tiny.cc/stumpy-demo\")\n\n        return heroku_div\n\n    def get_slider(self, value=0):\n        slider = Slider(\n            start=0.0,\n            end=max(self.df[\"index\"]) - self.window,\n            value=value,\n            step=1,\n            title=\"Subsequence\",\n            sizing_mode=self.sizing_mode,\n        )\n        return slider\n\n    def get_play_button(self):\n        play_btn = Button(label=\"► Play\")\n        play_btn.on_click(self.animate)\n        return play_btn\n\n    def get_text_input(self):\n        txt_inp = TextInput(sizing_mode=self.sizing_mode)\n        return txt_inp\n\n    def get_buttons(self):\n        pattern_btn = Button(label=\"Show Motif\", sizing_mode=self.sizing_mode)\n        match_btn = Button(label=\"Show Nearest Neighbor\", sizing_mode=self.sizing_mode)\n        reset_btn = Button(label=\"Reset\", sizing_mode=self.sizing_mode, button_type=\"primary\")\n        return pattern_btn, match_btn, reset_btn\n\n    def update_plots(self, attr, new, old):\n        self.quad_cds.data = self.get_quad_dict(self.df, self.slider.value)\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, self.slider.value\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, self.slider.value)\n\n    def custom_update_plots(self, attr, new, old):\n        self.quad_cds.data = self.get_custom_quad_dict(\n            self.df, self.pattern_idx, self.slider.value\n        )\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, self.pattern_idx, self.slider.value\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, self.slider.value)\n        dist = self.df[\"distance\"].loc[self.slider.value]\n\n    def show_hide_pattern(self):\n        pattern_quad = self.ts_plot.select(name=\"pattern_quad\")[0]\n        pattern_start = self.mp_plot.select(name=\"pattern_start\")[0]\n        pattern_line = self.pm_plot.select(name=\"pattern_line\")[0]\n        if pattern_quad.visible:\n            pattern_start.visible = False\n            pattern_line.visible = False\n            pattern_quad.visible = False\n            self.pattern_btn.label = \"Show Motif\"\n        else:\n            pattern_start.visible = True\n            pattern_line.visible = True\n            pattern_quad.visible = True\n            self.pattern_btn.label = \"Hide Motif\"\n\n    def show_hide_match(self):\n        match_quad = self.ts_plot.select(name=\"match_quad\")[0]\n        match_dist = self.mp_plot.select(name=\"match_dist\")[0]\n        match_line = self.pm_plot.select(name=\"match_line\")[0]\n        if match_quad.visible:\n            match_dist.visible = False\n            match_line.visible = False\n            match_quad.visible = False\n            self.match_btn.label = \"Show Nearest Neighbor\"\n        else:\n            match_dist.visible = True\n            match_line.visible = True\n            match_quad.visible = True\n            self.match_btn.label = \"Hide Nearest Neighbor\"\n\n    def update_slider(self, attr, old, new):\n        self.slider.value = int(self.txt_inp.value)\n\n    def animate(self):\n        if self.play_btn.label == \"► Play\":\n            self.play_btn.label = \"❚❚ Pause\"\n            self.animation.start()\n        else:\n            self.play_btn.label = \"► Play\"\n            self.animation.stop()\n\n    def update_animate(self, shift=50):\n        if self.window &lt; self.m:  # Probably using box select\n            start = self.slider.value\n            end = start + shift\n            if self.df.loc[start:end, \"distance\"].min() &lt;= 15:\n                self.slider.value = self.df.loc[start:end, \"distance\"].idxmin()\n                self.animate()\n            elif self.slider.value + shift &lt;= self.slider.end:\n                self.slider.value = self.slider.value + shift\n            else:\n                self.slider.value = 0\n        elif self.slider.value + shift &lt;= self.slider.end:\n            self.slider.value = self.slider.value + shift\n        else:\n            self.slider.value = 0\n\n    def reset(self):\n        self.sizing_mode = \"stretch_both\"\n        self.window = self.m\n\n        self.default_idx = self.min_distance_idx\n        self.df = self.get_df_from_file()\n        self.ts_cds.data = self.get_ts_dict(self.df)\n        self.mp_plot.y_range.end = max(self.df[\"distance\"])\n        self.mp_plot.title.text = \"Matrix Profile (All Minimum Distances)\"\n        self.mp_plot.y_range.bounds = (0, max(self.df[\"distance\"]))\n        self.quad_cds.data = self.get_quad_dict(self.df, pattern_idx=self.default_idx)\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, pattern_idx=self.default_idx\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, pattern_idx=self.default_idx)\n        self.circle_cds.data = self.get_circle_dict(self.df)\n        # Remove callback and add old callback\n        if self.custom_update_plots in self.slider._callbacks[\"value\"]:\n            self.slider.remove_on_change(\"value\", self.custom_update_plots)\n            self.slider.on_change(\"value\", self.update_plots)\n        self.slider.end = self.df.shape[0] - self.window\n        self.slider.value = self.default_idx\n\n    def get_data(self):\n        self.df = self.get_df_from_file()\n        self.default_idx = self.min_distance_idx\n        self.ts_cds = ColumnDataSource(self.get_ts_dict(self.df))\n        self.quad_cds = ColumnDataSource(\n            self.get_quad_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.pattern_match_cds = ColumnDataSource(\n            self.get_pattern_match_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.dist_cds = ColumnDataSource(\n            self.get_dist_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.circle_cds = ColumnDataSource(self.get_circle_dict(self.df))\n\n    def get_plots(self, ts_plot_color=\"black\"):\n        self.ts_plot = self.get_ts_plot(color=ts_plot_color)\n        self.mp_plot = self.get_mp_plot()\n        self.pm_plot = self.get_pm_plot()\n\n    def get_widgets(self):\n        self.slider = self.get_slider(value=self.default_idx)\n        self.play_btn = self.get_play_button()\n        self.txt_inp = self.get_text_input()\n        self.pattern_btn, self.match_btn, self.reset_btn = self.get_buttons()\n        self.logo_div = self.get_logo_div()\n        self.heroku_div = self.get_heroku_div()\n\n    def set_callbacks(self):\n        self.slider.on_change(\"value\", self.update_plots)\n        self.pattern_btn.on_click(self.show_hide_pattern)\n        self.show_hide_pattern()\n        self.match_btn.on_click(self.show_hide_match)\n        self.show_hide_match()\n        self.reset_btn.on_click(self.reset)\n        self.txt_inp.on_change(\"value\", self.update_slider)\n\n    def get_layout(self):\n        self.get_data()\n        self.get_plots()\n        self.get_widgets()\n        self.set_callbacks()\n\n        l = layout(\n            [\n                [self.ts_plot],\n                [self.mp_plot],\n                [self.pm_plot],\n                [self.slider],\n                [self.pattern_btn, self.match_btn, self.play_btn, self.logo_div],\n            ],\n            sizing_mode=self.sizing_mode,\n        )\n\n        return l\n\n    def get_raw_layout(self):\n        self.get_data()\n        self.get_plots(ts_plot_color=\"#54b847\")\n\n        l = layout([[self.ts_plot], [self.mp_plot]], sizing_mode=self.sizing_mode)\n\n        return l\n\n\ndashboard = StumpyBokehDashboard()\n\ndef get_components(dashboard: StumpyBokehDashboard=dashboard):\n    dashboard.get_data()\n    dashboard.get_plots()\n    dashboard.get_widgets()\n    dashboard.set_callbacks()\n\n    logo = dashboard.logo_div\n    settings = layout(\n        dashboard.pattern_btn,\n        dashboard.match_btn,\n        dashboard.play_btn,\n        dashboard.slider,\n        height=150,\n        sizing_mode=\"stretch_width\",\n    )\n    main = layout(\n        [\n            [dashboard.ts_plot],\n            [dashboard.mp_plot],\n            [dashboard.pm_plot],\n        ],\n        sizing_mode=dashboard.sizing_mode,\n    )\n    return logo, settings, main\n\npn.extension(template=\"fast\")\npn.state.template.param.update(\n    site_url=\"https://awesome-panel.org\",\n    site=\"Awesome Panel\",\n    title=\"Stumpy Timeseries Analysis\",\n    favicon=\"https://raw.githubusercontent.com/MarcSkovMadsen/awesome-panel-assets/320297ccb92773da099f6b97d267cc0433b67c23/favicon/ap-1f77b4.ico\",\n    header_background=\"#459db9\",\n    theme_toggle=False,\n)\n\nlogo, settings, main = get_components()\n\npn.Column(\n    logo,\n    settings, sizing_mode=\"stretch_width\",\n).servable(target=\"sidebar\")\npn.panel(main, sizing_mode=\"stretch_both\", max_height=800).servable(target=\"main\")\n\nDownload (right-click, save-as)"
  },
  {
    "objectID": "resources/stumpy/index.html#gif",
    "href": "resources/stumpy/index.html#gif",
    "title": "Stumpy",
    "section": "Gif",
    "text": "Gif\nI think the app looks amazing. Its really performant too."
  },
  {
    "objectID": "resources/stumpy/index.html#png",
    "href": "resources/stumpy/index.html#png",
    "title": "Stumpy",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/stumpy/index.html#mp4",
    "href": "resources/stumpy/index.html#mp4",
    "title": "Stumpy",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "resources/async_tasks/index.html",
    "href": "resources/async_tasks/index.html",
    "title": "Async Tasks",
    "section": "",
    "text": "When creating awesome analytics apps you sometimes want to run blocking tasks asynchronously in a background thread. Panel supports this as its running on top of the asynchronous web server Tornado.\nThe app below shows how to start a background thread that updates a progressbar while the rest of the application remains responsive. We utilize a ThreadPoolExecutor and async to achieve this."
  },
  {
    "objectID": "resources/async_tasks/index.html#introduction",
    "href": "resources/async_tasks/index.html#introduction",
    "title": "Async Tasks",
    "section": "",
    "text": "When creating awesome analytics apps you sometimes want to run blocking tasks asynchronously in a background thread. Panel supports this as its running on top of the asynchronous web server Tornado.\nThe app below shows how to start a background thread that updates a progressbar while the rest of the application remains responsive. We utilize a ThreadPoolExecutor and async to achieve this."
  },
  {
    "objectID": "resources/async_tasks/index.html#app",
    "href": "resources/async_tasks/index.html#app",
    "title": "Async Tasks",
    "section": "App",
    "text": "App\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/async_tasks/index.html#code",
    "href": "resources/async_tasks/index.html#code",
    "title": "Async Tasks",
    "section": "Code",
    "text": "Code\n\n\nShow\n\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\nfrom contextlib import contextmanager\n\nimport numpy as np\nimport panel as pn\nimport param\nfrom asyncio import wrap_future\n\nclass ProgressExtMod(pn.viewable.Viewer):\n    \"\"\"A custom component for easy progress reporting\"\"\"\n\n    completed = param.Integer(default=0)\n    bar_color = param.String(default=\"info\")\n    num_tasks = param.Integer(default=100, bounds=(1, None))\n\n    # @param.depends('completed', 'num_tasks')\n    @property\n    def value(self) -&gt; int:\n        \"\"\"Returns the progress value\n\n        Returns:\n            int: The progress value\n        \"\"\"\n        return int(100 * (self.completed / self.num_tasks))\n\n    def reset(self):\n        \"\"\"Resets the value and message\"\"\"\n        # Please note the order matters as the Widgets updates two times. One for each change\n        self.completed = 0\n\n    def __panel__(self):\n        return self.view\n\n    @param.depends(\"completed\", \"bar_color\")\n    def view(self):\n        \"\"\"View the widget\n        Returns:\n            pn.viewable.Viewable: Add this to your app to see the progress reported\n        \"\"\"\n        if self.value:\n            return pn.widgets.Progress(\n                active=True, value=self.value, align=\"center\", sizing_mode=\"stretch_width\"\n            )\n        return None\n\n    @contextmanager\n    def increment(self):\n        \"\"\"Increments the value\n        \n        Can be used as context manager or decorator\n        \n        Yields:\n            None: Nothing is yielded\n        \"\"\"\n        self.completed += 1\n        yield\n        if self.completed == self.num_tasks:\n            self.reset()\n\nexecutor = ThreadPoolExecutor(max_workers=2)  # pylint: disable=consider-using-with\nprogress = ProgressExtMod()\n\n\nclass AsyncComponent(pn.viewable.Viewer):\n    \"\"\"A component that demonstrates how to run a Blocking Background task asynchronously\n    in Panel\"\"\"\n\n    select = param.Selector(objects=range(10))\n    slider = param.Number(2, bounds=(0, 10))\n    \n    run_blocking_task = param.Event(label=\"RUN\")\n    result = param.Number(0)\n    view = param.Parameter()\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self._layout = pn.Column(\n            pn.pane.Markdown(\"## Blocking Task Running in Background\"),\n            pn.Param(\n                self,\n                parameters=[\"run_blocking_task\", \"result\"],\n                widgets={\"result\": {\"disabled\": True}, \"run_blocking_task\": {\"button_type\": \"primary\"}},\n                show_name=False,\n            ),\n            progress,\n            pn.pane.Markdown(\"## Other, Non-Blocked Tasks\"),\n            pn.Param(\n                self,\n                parameters=[\"select\", \"slider\"],\n                widgets={\"text\": {\"disabled\": True}},\n                show_name=False,\n            ),\n            self.text\n        )\n\n    def __panel__(self):\n        return self._layout\n\n    @param.depends(\"slider\", \"select\")\n    def text(self):\n        if self.select:\n            select = self.select\n        else:\n            select = 0\n        return f\"{select} + {self.slider} = {select + self.slider}\"\n\n    @pn.depends(\"run_blocking_task\", watch=True)\n    async def _run_blocking_tasks(self, num_tasks=10):\n        \"\"\"Runs background tasks num_tasks times\"\"\"\n        num_tasks = 20\n        progress.num_tasks = num_tasks\n        for _ in range(num_tasks):\n            future = executor.submit(self._run_blocking_task)\n            result = await wrap_future(future)\n            self._update(result)\n\n    @progress.increment()\n    def _update(self, number):\n        self.result += number\n\n    @staticmethod\n    def _run_blocking_task():\n        time.sleep(np.random.randint(1, 2))\n        return 5\n\nif pn.state.served:\n    pn.extension()\n    \n    component = AsyncComponent()\n    pn.template.FastListTemplate(\n        site=\"Awesome Panel\", site_url=\"https://awesome-panel.org\", title=\"Async Tasks\", main=[component], main_layout=None, main_max_width=\"400px\"\n    ).servable()"
  },
  {
    "objectID": "resources/async_tasks/index.html#gif",
    "href": "resources/async_tasks/index.html#gif",
    "title": "Async Tasks",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/async_tasks/index.html#png",
    "href": "resources/async_tasks/index.html#png",
    "title": "Async Tasks",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/async_tasks/index.html#mp4",
    "href": "resources/async_tasks/index.html#mp4",
    "title": "Async Tasks",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About\nWe want to show how awesome Panel by HoloViz is and push the framework forward.\n\n\n\nAwesome Panel Intro\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Awesome Panel",
    "section": "",
    "text": "Panel by HoloViz is the powerful data exploration & web app framework for Python.\nCheck out the awesome community resources below.\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nAsync Tasks\n\n\n\n\n\n\n\nasync\n\n\nthreads\n\n\n\n\nRun blocking tasks in the background using a ThreadPoolExecutor and Async\n\n\n\n\n\n\nDec 22, 2023\n\n\nJochem Smit, Marc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nBootstrap Dashboard\n\n\n\n\n\n\n\ndashboard\n\n\nhvplot\n\n\n\n\nA Bootstrap like dashboard\n\n\n\n\n\n\nDec 22, 2023\n\n\nMarc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nStumpy\n\n\n\n\n\n\n\nbokeh\n\n\npyodide\n\n\ntimeseries\n\n\n\n\nUse the Stumpy library to identify patterns in timeseries\n\n\n\n\n\n\nDec 22, 2023\n\n\nMarc Skov Madsen, Sean Law\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html",
    "href": "resources/bootstrap_dashboard/index.html",
    "title": "Bootstrap Dashboard",
    "section": "",
    "text": "This dashboard demonstrates that a dashboard layout similar to the Bootstrap dashboard template can be implemented in Panel."
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#introduction",
    "href": "resources/bootstrap_dashboard/index.html#introduction",
    "title": "Bootstrap Dashboard",
    "section": "",
    "text": "This dashboard demonstrates that a dashboard layout similar to the Bootstrap dashboard template can be implemented in Panel."
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#app",
    "href": "resources/bootstrap_dashboard/index.html#app",
    "title": "Bootstrap Dashboard",
    "section": "App",
    "text": "App\nThis app runs entirely in the browser via Pyodide and panel convert.\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#code",
    "href": "resources/bootstrap_dashboard/index.html#code",
    "title": "Bootstrap Dashboard",
    "section": "Code",
    "text": "Code\n\n\nShow\n\n\"\"\"The purpose of this app is to test that a **multi-page Dashboard Layout** similar to the\n[bootstrap dashboard template](https://getbootstrap.com/docs/4.3/examples/dashboard/)\nfrom [getboostrap.com](https://getbootstrap.com/) can be implemented in\n[Panel](https://panel.pyviz.org/).\n\"\"\"\nimport hvplot.pandas  # pylint: disable=unused-import\nimport pandas as pd\nimport panel as pn\n\nBOOTSTRAP_DASHBOARD_CHART_URL=\"https://awesomepanel.blob.core.windows.net/resources/bootstrap_dashboard/bootstrap_dashboard_chart.csv\"\nBOOTSTRAP_DASHBOARD_TABLE_URL=\"https://awesomepanel.blob.core.windows.net/resources/bootstrap_dashboard/bootstrap_dashboard_table.csv\"\n\nCOLOR=\"#0072B5\"\n\n@pn.cache\ndef _get_chart_data():\n    return pd.read_csv(BOOTSTRAP_DASHBOARD_CHART_URL)\n\n@pn.cache\ndef _get_table_data():\n    return pd.read_csv(BOOTSTRAP_DASHBOARD_TABLE_URL)\n\ndef _holoviews_chart():\n    \"\"\"## Dashboard Orders Chart generated by HoloViews\"\"\"\n    data = _get_chart_data()\n    line_plot = data.hvplot.line(\n        x=\"Day\",\n        y=\"Orders\",\n        height=500,\n        line_color=COLOR,\n        line_width=6,\n    )\n    scatter_plot = data.hvplot.scatter(x=\"Day\", y=\"Orders\", height=300,).opts(\n        marker=\"o\",\n        size=10,\n        color=COLOR,\n    )\n    fig = line_plot * scatter_plot\n    gridstyle = {\n        \"grid_line_color\": \"black\",\n        \"grid_line_width\": 0.1,\n    }\n    fig = fig.opts(\n        responsive=True,\n        toolbar=None,\n        yticks=list(\n            range(\n                12000,\n                26000,\n                2000,\n            )\n        ),\n        ylim=(\n            12000,\n            26000,\n        ),\n        gridstyle=gridstyle,\n        show_grid=True,\n    )\n    return fig\n\napp = pn.extension(\"tabulator\", sizing_mode=\"stretch_width\")\n\npn.template.FastListTemplate(\n    site=\"Awesome Panel\", site_url=\"https://awesome-panel.org\", title=\"Bootstrap Dashboard\",\n    main=[\n        pn.Column(\n            pn.pane.Markdown(\"## Dashboard\"),\n            _holoviews_chart()),\n            pn.Column(pn.pane.Markdown(\"## Section Title\"),\n            pn.widgets.Tabulator(_get_table_data(), layout='fit_data_stretch')),\n    ], main_max_width=\"800px\", main_layout=None,\n).servable()\n\n\nDownload (right-click, save-as)"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#gif",
    "href": "resources/bootstrap_dashboard/index.html#gif",
    "title": "Bootstrap Dashboard",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#png",
    "href": "resources/bootstrap_dashboard/index.html#png",
    "title": "Bootstrap Dashboard",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#mp4",
    "href": "resources/bootstrap_dashboard/index.html#mp4",
    "title": "Bootstrap Dashboard",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  }
]