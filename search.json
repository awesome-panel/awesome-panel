[
  {
    "objectID": "resources/tasty_map/index.html",
    "href": "resources/tasty_map/index.html",
    "title": "Tasty Map",
    "section": "",
    "text": "TastyMap makes it easy to customize and use colormaps, any way you like.\nThe app is a Panel app.\n\nStar"
  },
  {
    "objectID": "resources/tasty_map/index.html#introduction",
    "href": "resources/tasty_map/index.html#introduction",
    "title": "Tasty Map",
    "section": "",
    "text": "TastyMap makes it easy to customize and use colormaps, any way you like.\nThe app is a Panel app.\n\nStar"
  },
  {
    "objectID": "resources/tasty_map/index.html#gif",
    "href": "resources/tasty_map/index.html#gif",
    "title": "Tasty Map",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/panel_chat_examples/index.html",
    "href": "resources/panel_chat_examples/index.html",
    "title": "Panel Chat Examples",
    "section": "",
    "text": "Panel Chat Examples provides example Panel Chat Apps.\nPanels Chat Components are multi modal and supports LangChain, OpenAI, Mistral, Llama, etc.\n\nStar"
  },
  {
    "objectID": "resources/panel_chat_examples/index.html#introduction",
    "href": "resources/panel_chat_examples/index.html#introduction",
    "title": "Panel Chat Examples",
    "section": "",
    "text": "Panel Chat Examples provides example Panel Chat Apps.\nPanels Chat Components are multi modal and supports LangChain, OpenAI, Mistral, Llama, etc.\n\nStar"
  },
  {
    "objectID": "resources/panel_chat_examples/index.html#mp4",
    "href": "resources/panel_chat_examples/index.html#mp4",
    "title": "Panel Chat Examples",
    "section": "MP4",
    "text": "MP4"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html",
    "href": "resources/bootstrap_dashboard/index.html",
    "title": "Bootstrap Dashboard",
    "section": "",
    "text": "This dashboard demonstrates that a dashboard layout similar to the Bootstrap dashboard template can be implemented in Panel."
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#introduction",
    "href": "resources/bootstrap_dashboard/index.html#introduction",
    "title": "Bootstrap Dashboard",
    "section": "",
    "text": "This dashboard demonstrates that a dashboard layout similar to the Bootstrap dashboard template can be implemented in Panel."
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#app",
    "href": "resources/bootstrap_dashboard/index.html#app",
    "title": "Bootstrap Dashboard",
    "section": "App",
    "text": "App\nThis app runs entirely in the browser via Pyodide and panel convert.\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#code",
    "href": "resources/bootstrap_dashboard/index.html#code",
    "title": "Bootstrap Dashboard",
    "section": "Code",
    "text": "Code\n\n\nShow\n\n\"\"\"The purpose of this app is to test that a **multi-page Dashboard Layout** similar to the\n[bootstrap dashboard template](https://getbootstrap.com/docs/4.3/examples/dashboard/)\nfrom [getboostrap.com](https://getbootstrap.com/) can be implemented in\n[Panel](https://panel.pyviz.org/).\n\"\"\"\nimport hvplot.pandas  # pylint: disable=unused-import\nimport pandas as pd\nimport panel as pn\n\nBOOTSTRAP_DASHBOARD_CHART_URL=\"https://awesomepanel.blob.core.windows.net/resources/bootstrap_dashboard/bootstrap_dashboard_chart.csv\"\nBOOTSTRAP_DASHBOARD_TABLE_URL=\"https://awesomepanel.blob.core.windows.net/resources/bootstrap_dashboard/bootstrap_dashboard_table.csv\"\n\nCOLOR=\"#0072B5\"\n\n@pn.cache\ndef _get_chart_data():\n    return pd.read_csv(BOOTSTRAP_DASHBOARD_CHART_URL)\n\n@pn.cache\ndef _get_table_data():\n    return pd.read_csv(BOOTSTRAP_DASHBOARD_TABLE_URL)\n\ndef _holoviews_chart():\n    \"\"\"## Dashboard Orders Chart generated by HoloViews\"\"\"\n    data = _get_chart_data()\n    line_plot = data.hvplot.line(\n        x=\"Day\",\n        y=\"Orders\",\n        height=500,\n        line_color=COLOR,\n        line_width=6,\n    )\n    scatter_plot = data.hvplot.scatter(x=\"Day\", y=\"Orders\", height=300,).opts(\n        marker=\"o\",\n        size=10,\n        color=COLOR,\n    )\n    fig = line_plot * scatter_plot\n    gridstyle = {\n        \"grid_line_color\": \"black\",\n        \"grid_line_width\": 0.1,\n    }\n    fig = fig.opts(\n        responsive=True,\n        toolbar=None,\n        yticks=list(\n            range(\n                12000,\n                26000,\n                2000,\n            )\n        ),\n        ylim=(\n            12000,\n            26000,\n        ),\n        gridstyle=gridstyle,\n        show_grid=True,\n    )\n    return fig\n\napp = pn.extension(\"tabulator\", sizing_mode=\"stretch_width\")\n\npn.template.FastListTemplate(\n    site=\"Awesome Panel\", site_url=\"https://awesome-panel.org\", title=\"Bootstrap Dashboard\",\n    main=[\n        pn.Column(\n            pn.pane.Markdown(\"## Dashboard\"),\n            _holoviews_chart()),\n            pn.Column(pn.pane.Markdown(\"## Section Title\"),\n            pn.widgets.Tabulator(_get_table_data(), layout='fit_data_stretch')),\n    ], main_max_width=\"800px\", main_layout=None,\n).servable()\n\n\nDownload (right-click, save-as)"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#gif",
    "href": "resources/bootstrap_dashboard/index.html#gif",
    "title": "Bootstrap Dashboard",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#png",
    "href": "resources/bootstrap_dashboard/index.html#png",
    "title": "Bootstrap Dashboard",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/bootstrap_dashboard/index.html#mp4",
    "href": "resources/bootstrap_dashboard/index.html#mp4",
    "title": "Bootstrap Dashboard",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Awesome Panel",
    "section": "",
    "text": "Panel by HoloViz is the powerful data exploration & web app framework for Python.\n\nStar\nPlease give Panel a ⭐ on Github, then check out the awesome community resources below.\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nCaching Example\n\n\n\n\n\n\n\nperformance\n\n\n\n\nLearn how caching can speed up your app\n\n\n\n\n\n\nJan 7, 2024\n\n\nMarc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nAsync Tasks\n\n\n\n\n\n\n\nasync\n\n\nthreads\n\n\n\n\nRun blocking tasks in the background using a ThreadPoolExecutor and Async\n\n\n\n\n\n\nJan 6, 2024\n\n\nJochem Smit, Marc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nBootstrap Dashboard\n\n\n\n\n\n\n\ndashboard\n\n\nhvplot\n\n\n\n\nA Bootstrap like dashboard\n\n\n\n\n\n\nJan 6, 2024\n\n\nMarc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nPanel Chat Examples\n\n\n\n\n\n\n\nartificial intelligence\n\n\nllm\n\n\n\n\nA resource of Panel Chat Apps using Mistral, LangChain, LlamaIndex, OpenAI etc.\n\n\n\n\n\n\nJan 6, 2024\n\n\nAndrew Huang, Marc Skov Madsen\n\n\n\n\n\n\n  \n\n\n\n\nStumpy\n\n\n\n\n\n\n\nbokeh\n\n\npyodide\n\n\ntimeseries\n\n\n\n\nUse the Stumpy library to identify patterns in timeseries\n\n\n\n\n\n\nJan 6, 2024\n\n\nMarc Skov Madsen, Sean Law\n\n\n\n\n\n\n  \n\n\n\n\nTasty Map\n\n\n\n\n\n\n\ncolor\n\n\n\n\nGenerate custom color palettes easily using the TastyMap Panel app\n\n\n\n\n\n\nJan 6, 2024\n\n\nAndrew Huang\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About\nWe want to show how awesome Panel by HoloViz is and push the framework forward.\nIf you like this project please give us a ⭐ on Github.\n\nStar\n\n\n\nAwesome Panel Intro\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "resources/async_tasks/index.html",
    "href": "resources/async_tasks/index.html",
    "title": "Async Tasks",
    "section": "",
    "text": "When creating awesome analytics apps you sometimes want to run blocking tasks asynchronously in a background thread. Panel supports this as its running on top of the asynchronous web server Tornado.\nThe app below shows how to start a background thread that updates a progressbar while the rest of the application remains responsive. We utilize a ThreadPoolExecutor and async to achieve this."
  },
  {
    "objectID": "resources/async_tasks/index.html#introduction",
    "href": "resources/async_tasks/index.html#introduction",
    "title": "Async Tasks",
    "section": "",
    "text": "When creating awesome analytics apps you sometimes want to run blocking tasks asynchronously in a background thread. Panel supports this as its running on top of the asynchronous web server Tornado.\nThe app below shows how to start a background thread that updates a progressbar while the rest of the application remains responsive. We utilize a ThreadPoolExecutor and async to achieve this."
  },
  {
    "objectID": "resources/async_tasks/index.html#app",
    "href": "resources/async_tasks/index.html#app",
    "title": "Async Tasks",
    "section": "App",
    "text": "App\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/async_tasks/index.html#code",
    "href": "resources/async_tasks/index.html#code",
    "title": "Async Tasks",
    "section": "Code",
    "text": "Code\n\n\nShow\n\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\nfrom contextlib import contextmanager\n\nimport numpy as np\nimport panel as pn\nimport param\nfrom asyncio import wrap_future\n\nclass ProgressExtMod(pn.viewable.Viewer):\n    \"\"\"A custom component for easy progress reporting\"\"\"\n\n    completed = param.Integer(default=0)\n    bar_color = param.String(default=\"info\")\n    num_tasks = param.Integer(default=100, bounds=(1, None))\n\n    # @param.depends('completed', 'num_tasks')\n    @property\n    def value(self) -&gt; int:\n        \"\"\"Returns the progress value\n\n        Returns:\n            int: The progress value\n        \"\"\"\n        return int(100 * (self.completed / self.num_tasks))\n\n    def reset(self):\n        \"\"\"Resets the value and message\"\"\"\n        # Please note the order matters as the Widgets updates two times. One for each change\n        self.completed = 0\n\n    def __panel__(self):\n        return self.view\n\n    @param.depends(\"completed\", \"bar_color\")\n    def view(self):\n        \"\"\"View the widget\n        Returns:\n            pn.viewable.Viewable: Add this to your app to see the progress reported\n        \"\"\"\n        if self.value:\n            return pn.widgets.Progress(\n                active=True, value=self.value, align=\"center\", sizing_mode=\"stretch_width\"\n            )\n        return None\n\n    @contextmanager\n    def increment(self):\n        \"\"\"Increments the value\n        \n        Can be used as context manager or decorator\n        \n        Yields:\n            None: Nothing is yielded\n        \"\"\"\n        self.completed += 1\n        yield\n        if self.completed == self.num_tasks:\n            self.reset()\n\nexecutor = ThreadPoolExecutor(max_workers=2)  # pylint: disable=consider-using-with\nprogress = ProgressExtMod()\n\n\nclass AsyncComponent(pn.viewable.Viewer):\n    \"\"\"A component that demonstrates how to run a Blocking Background task asynchronously\n    in Panel\"\"\"\n\n    select = param.Selector(objects=range(10))\n    slider = param.Number(2, bounds=(0, 10))\n    \n    run_blocking_task = param.Event(label=\"RUN\")\n    result = param.Number(0)\n    view = param.Parameter()\n\n    def __init__(self, **params):\n        super().__init__(**params)\n\n        self._layout = pn.Column(\n            pn.pane.Markdown(\"## Blocking Task Running in Background\"),\n            pn.Param(\n                self,\n                parameters=[\"run_blocking_task\", \"result\"],\n                widgets={\"result\": {\"disabled\": True}, \"run_blocking_task\": {\"button_type\": \"primary\"}},\n                show_name=False,\n            ),\n            progress,\n            pn.pane.Markdown(\"## Other, Non-Blocked Tasks\"),\n            pn.Param(\n                self,\n                parameters=[\"select\", \"slider\"],\n                widgets={\"text\": {\"disabled\": True}},\n                show_name=False,\n            ),\n            self.text\n        )\n\n    def __panel__(self):\n        return self._layout\n\n    @param.depends(\"slider\", \"select\")\n    def text(self):\n        if self.select:\n            select = self.select\n        else:\n            select = 0\n        return f\"{select} + {self.slider} = {select + self.slider}\"\n\n    @pn.depends(\"run_blocking_task\", watch=True)\n    async def _run_blocking_tasks(self, num_tasks=10):\n        \"\"\"Runs background tasks num_tasks times\"\"\"\n        num_tasks = 20\n        progress.num_tasks = num_tasks\n        for _ in range(num_tasks):\n            future = executor.submit(self._run_blocking_task)\n            result = await wrap_future(future)\n            self._update(result)\n\n    @progress.increment()\n    def _update(self, number):\n        self.result += number\n\n    @staticmethod\n    def _run_blocking_task():\n        time.sleep(np.random.randint(1, 2))\n        return 5\n\nif pn.state.served:\n    pn.extension()\n    \n    component = AsyncComponent()\n    pn.template.FastListTemplate(\n        site=\"Awesome Panel\", site_url=\"https://awesome-panel.org\", title=\"Async Tasks\", main=[component], main_layout=None, main_max_width=\"400px\"\n    ).servable()"
  },
  {
    "objectID": "resources/async_tasks/index.html#gif",
    "href": "resources/async_tasks/index.html#gif",
    "title": "Async Tasks",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/async_tasks/index.html#png",
    "href": "resources/async_tasks/index.html#png",
    "title": "Async Tasks",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/async_tasks/index.html#mp4",
    "href": "resources/async_tasks/index.html#mp4",
    "title": "Async Tasks",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "resources/caching_example/index.html",
    "href": "resources/caching_example/index.html",
    "title": "Caching Example",
    "section": "",
    "text": "In computing, a cache is a high-speed data storage layer which stores a subset of data, typically transient in nature, so that future requests for that data are served up faster than is possible by accessing the data’s primary storage location.\nCaching allows you to efficiently reuse previously retrieved or computed data to speed up your exploration, jobs or apps.\nGood caching solutions for Panel are summarized in the table below\n\n\n\nTechnology\nPerformance\nPersistant\nHorizontal Scaling\nVertical Scaling\nExpiration\nPreloading\nComments\n\n\n\n\npanel.cache\nVery Fast\nOptional\nOptional\nYes\nYes\nYes\nConfigurable\n\n\npanel.state.as_cached\nVery Fast\nOptional\nOptional\nYes\nYes\nYes\nConfigurable\n\n\npanel.state.cache\nVery Fast\nNo\nNo\nYes\nNo\nYes\nSimple Dict Cache\n\n\nDiskCache\nVery Fast\nYes\nNo\nYes\nYes\nYes\nSimple Persistent Cache\n\n\nRedis\nVery Fast\nYes\nYes\nYes\nYes\nYes\nServer solution. Works well with the distributed task queue Celery\n\n\n\nNote that\n\nExpiration enables caching data for a period of time for example seconds, minutes, hours or days.\nPreloading of a cache can be triggered by a cronjob or event.\nIf the cache is persisted, i.e. stored to disk or runs on a server like Redis it can enable caching data across jobs, applications, servers and restarts.\n\nTo learn more about caching check out the AWS Caching Overview"
  },
  {
    "objectID": "resources/caching_example/index.html#introduction",
    "href": "resources/caching_example/index.html#introduction",
    "title": "Caching Example",
    "section": "",
    "text": "In computing, a cache is a high-speed data storage layer which stores a subset of data, typically transient in nature, so that future requests for that data are served up faster than is possible by accessing the data’s primary storage location.\nCaching allows you to efficiently reuse previously retrieved or computed data to speed up your exploration, jobs or apps.\nGood caching solutions for Panel are summarized in the table below\n\n\n\nTechnology\nPerformance\nPersistant\nHorizontal Scaling\nVertical Scaling\nExpiration\nPreloading\nComments\n\n\n\n\npanel.cache\nVery Fast\nOptional\nOptional\nYes\nYes\nYes\nConfigurable\n\n\npanel.state.as_cached\nVery Fast\nOptional\nOptional\nYes\nYes\nYes\nConfigurable\n\n\npanel.state.cache\nVery Fast\nNo\nNo\nYes\nNo\nYes\nSimple Dict Cache\n\n\nDiskCache\nVery Fast\nYes\nNo\nYes\nYes\nYes\nSimple Persistent Cache\n\n\nRedis\nVery Fast\nYes\nYes\nYes\nYes\nYes\nServer solution. Works well with the distributed task queue Celery\n\n\n\nNote that\n\nExpiration enables caching data for a period of time for example seconds, minutes, hours or days.\nPreloading of a cache can be triggered by a cronjob or event.\nIf the cache is persisted, i.e. stored to disk or runs on a server like Redis it can enable caching data across jobs, applications, servers and restarts.\n\nTo learn more about caching check out the AWS Caching Overview"
  },
  {
    "objectID": "resources/caching_example/index.html#app",
    "href": "resources/caching_example/index.html#app",
    "title": "Caching Example",
    "section": "App",
    "text": "App\nThis app runs entirely in the browser via Pyodide and panel convert.\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/caching_example/index.html#code",
    "href": "resources/caching_example/index.html#code",
    "title": "Caching Example",
    "section": "Code",
    "text": "Code\n\n\nShow\n\n\"\"\"\n# Caching Example\n\nSee https://awesome-panel.org/resources/caching_example\n\"\"\"\nimport time\n\nimport hvplot.pandas  # pylint: disable=unused-import\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\npn.extension(design=\"material\")\n\nACCENT_COLOR = \"#1f77b4\"\n\nnp.random.seed([3, 1415])\nPERIODS = 1 * 24 * 60  # minutes. I.e. 1 days\nDATA = pd.DataFrame(\n    {\n        \"time\": pd.date_range(\"2020-01-01\", periods=PERIODS, freq=\"T\"),\n        \"price\": np.random.randn(PERIODS) + 98,\n    }\n)\n\ndef _load_data(frac=0.1):\n    time.sleep(0.5 + frac * 0.5)\n    return DATA.sample(frac=frac)\n\ndef _plot_data(frac=0.1):\n    time.sleep(0.5)\n    data = _load_data(frac)\n    return data.hvplot(x=\"time\", y=\"price\")\n\n@pn.cache(per_session=True, ttl=60*60*24)\ndef _plot_data_cached(frac):\n    return _plot_data(frac)\n\n\n# Create Widgets\nfraction = pn.widgets.FloatSlider(value=0.1, start=0.1, end=1.0, step=0.1, name=\"Fraction of data\")\nduration = pn.widgets.StaticText(value=\"\", name=\"Time to create plot\")\nuse_cache = pn.widgets.Checkbox(value=False, name=\"Use Cache\")\npreload_cache = pn.widgets.Button(name=\"Preload Cache\", button_type=\"primary\", disabled=True)\nclear_cache = pn.widgets.Button(name=\"Clear Cache\", disabled=True)\npreload_progress = pn.widgets.Progress(\n    name=\"Progress\", active=False, value=0, max=100, sizing_mode=\"stretch_width\", disabled=True\n)\n\nplot_panel = pn.pane.HoloViews(min_height=500, sizing_mode=\"stretch_both\")\n\n# Setup interactivity\ndef _clear_cache(*_):\n    _plot_data_cached.clear()\n\n\nclear_cache.on_click(_clear_cache)\n\n\ndef _preload_cache(*_):\n    for index in range(0, 11, 1):\n        frac_ = round(index / 10, 1)\n        preload_progress.value = int(frac_ * 100)\n        _plot_data_cached(frac_)\n    preload_progress.value = 0\n\n\npreload_cache.on_click(_preload_cache)\n\n\n@pn.depends(frac=fraction, watch=True)\ndef _update_plot(frac):\n    start_counter = time.perf_counter()\n\n    frac = round(frac, 1)\n    if use_cache.value:\n        plot = _plot_data_cached(frac)\n    else:\n        plot = _plot_data(frac)\n\n    end_counter = time.perf_counter()\n    duration.value = str(round(end_counter - start_counter, 4)) + \" seconds\"\n\n    # Please note DiskCache does not cache the options\n    plot.opts(color=ACCENT_COLOR, responsive=True)\n    plot_panel.object = plot\n\n\n@pn.depends(use_cache=use_cache, watch=True)\ndef _update_cache_widgets(use_cache):  # pylint: disable=redefined-outer-name\n    disabled = not use_cache\n    preload_cache.disabled = disabled\n    clear_cache.disabled = disabled\n    preload_progress.disabled = disabled\n\n\n# Layout the app\npn.Column(\n    pn.pane.Markdown(\n        \"# Speed up slow functions with caching\", sizing_mode=\"stretch_width\"\n    ),\n    fraction,\n    duration,\n    use_cache,\n    plot_panel,\n    pn.Row(preload_cache, clear_cache,),\n    preload_progress,\n).servable()\n\npn.state.onload(lambda: fraction.param.trigger(\"value\"))\n\nDownload (right-click, save-as)"
  },
  {
    "objectID": "resources/caching_example/index.html#gif",
    "href": "resources/caching_example/index.html#gif",
    "title": "Caching Example",
    "section": "Gif",
    "text": "Gif"
  },
  {
    "objectID": "resources/caching_example/index.html#png",
    "href": "resources/caching_example/index.html#png",
    "title": "Caching Example",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/caching_example/index.html#mp4",
    "href": "resources/caching_example/index.html#mp4",
    "title": "Caching Example",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "resources/stumpy/index.html",
    "href": "resources/stumpy/index.html",
    "title": "Stumpy",
    "section": "",
    "text": "STUMPY is a powerful and scalable Python library for identifying repeating patterns in your timeseries. It does this by efficiently computing something called a matrix profile.\nThe app is a Bokeh app wrapped in a nice Panel template."
  },
  {
    "objectID": "resources/stumpy/index.html#introduction",
    "href": "resources/stumpy/index.html#introduction",
    "title": "Stumpy",
    "section": "",
    "text": "STUMPY is a powerful and scalable Python library for identifying repeating patterns in your timeseries. It does this by efficiently computing something called a matrix profile.\nThe app is a Bokeh app wrapped in a nice Panel template."
  },
  {
    "objectID": "resources/stumpy/index.html#app",
    "href": "resources/stumpy/index.html#app",
    "title": "Stumpy",
    "section": "App",
    "text": "App\nThis app runs entirely in the browser via Pyodide and panel convert.\nOpen in a new window | Open in Hugging Face Spaces"
  },
  {
    "objectID": "resources/stumpy/index.html#code",
    "href": "resources/stumpy/index.html#code",
    "title": "Stumpy",
    "section": "Code",
    "text": "Code\n\n\nShow\n\n#!/usr/bin/env python\n\nimport panel as pn\nimport pandas as pd\n\nfrom bokeh.plotting import figure\nfrom bokeh.layouts import layout\nfrom bokeh.models import (\n    ColumnDataSource,\n    Range1d,\n    Slider,\n    Button,\n    TextInput,\n    LabelSet,\n    Circle,\n    Div,\n)\n\nclass StumpyBokehDashboard:\n    def __init__(self):\n        self.sizing_mode = \"stretch_both\"\n        self.window = 0\n        self.m = None\n\n        self.df = None\n        self.ts_cds = None\n        self.quad_cds = None\n        self.pattern_match_cds = None\n        self.dist_cds = None\n        self.circle_cds = None\n\n        self.ts_plot = None\n        self.mp_plot = None\n        self.pm_plot = None\n        self.logo_div = None\n        self.heroku_div = None\n\n        self.slider = None\n        self.play_btn = None\n        self.txt_inp = None\n        self.pattern_btn = None\n        self.match_btn = None\n        self.reset_btn = None\n        self.idx = None\n        self.min_distance_idx = None\n\n        self.animation = pn.state.add_periodic_callback(\n            self.update_animate, 50, start=False\n        )\n\n    def get_df_from_file(self):\n        raw_df = pd.read_csv(\n            \"https://raw.githubusercontent.com/seanlaw/stumpy-live-demo/master/raw.csv\"\n        )\n\n        mp_df = pd.read_csv(\n            \"https://raw.githubusercontent.com/seanlaw/stumpy-live-demo/master/matrix_profile.csv\"\n        )\n\n        self.window = raw_df.shape[0] - mp_df.shape[0] + 1\n        self.m = raw_df.shape[0] - mp_df.shape[0] + 1\n        self.min_distance_idx = mp_df[\"distance\"].argmin()\n\n        df = pd.merge(raw_df, mp_df, left_index=True, how=\"left\", right_index=True)\n\n        return df.reset_index()\n\n    def get_ts_dict(self, df):\n        return self.df.to_dict(orient=\"list\")\n\n    def get_circle_dict(self, df):\n        return self.df[[\"index\", \"y\"]].to_dict(orient=\"list\")\n\n    def get_quad_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df.loc[pattern_idx, \"idx\"].astype(int)\n        quad_dict = dict(\n            pattern_left=[pattern_idx],\n            pattern_right=[pattern_idx + self.window - 1],\n            pattern_top=[max(df[\"y\"])],\n            pattern_bottom=[0],\n            match_left=[match_idx],\n            match_right=[match_idx + self.window - 1],\n            match_top=[max(df[\"y\"])],\n            match_bottom=[0],\n            vert_line_left=[pattern_idx - 5],\n            vert_line_right=[pattern_idx + 5],\n            vert_line_top=[max(df[\"distance\"])],\n            vert_line_bottom=[0],\n            hori_line_left=[0],\n            hori_line_right=[max(df[\"index\"])],\n            hori_line_top=[df.loc[pattern_idx, \"distance\"] - 0.01],\n            hori_line_bottom=[df.loc[pattern_idx, \"distance\"] + 0.01],\n        )\n        return quad_dict\n\n    def get_custom_quad_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df.loc[pattern_idx, \"idx\"].astype(int)\n        quad_dict = dict(\n            pattern_left=[pattern_idx],\n            pattern_right=[pattern_idx + self.window - 1],\n            pattern_top=[max(df[\"y\"])],\n            pattern_bottom=[0],\n            match_left=[match_idx],\n            match_right=[match_idx + self.window - 1],\n            match_top=[max(df[\"y\"])],\n            match_bottom=[0],\n            vert_line_left=[match_idx - 5],\n            vert_line_right=[match_idx + 5],\n            vert_line_top=[max(df[\"distance\"])],\n            vert_line_bottom=[0],\n            hori_line_left=[0],\n            hori_line_right=[max(df[\"index\"])],\n            hori_line_top=[df.loc[match_idx, \"distance\"] - 0.01],\n            hori_line_bottom=[df.loc[match_idx, \"distance\"] + 0.01],\n        )\n        return quad_dict\n\n    def get_pattern_match_dict(self, df, pattern_idx=0, match_idx=None):\n        if match_idx is None:\n            match_idx = df[\"idx\"].loc[pattern_idx].astype(int)\n        pattern_match_dict = dict(\n            index=list(range(self.window)),\n            pattern=df[\"y\"].loc[pattern_idx : pattern_idx + self.window - 1],\n            match=df[\"y\"].loc[match_idx : match_idx + self.window - 1],\n        )\n\n        return pattern_match_dict\n\n    def get_ts_plot(self, color=\"black\"):\n        \"\"\"\n        Time Series Plot\n        \"\"\"\n        ts_plot = figure(\n            toolbar_location=\"above\",\n            sizing_mode=self.sizing_mode,\n            title=\"Raw Time Series or Sequence\",\n            tools=[\"reset\"],\n        )\n        q = ts_plot.quad(\n            \"pattern_left\",\n            \"pattern_right\",\n            \"pattern_top\",\n            \"pattern_bottom\",\n            source=self.quad_cds,\n            name=\"pattern_quad\",\n            color=\"#54b847\",\n        )\n        q.visible = False\n        q = ts_plot.quad(\n            \"match_left\",\n            \"match_right\",\n            \"match_top\",\n            \"match_bottom\",\n            source=self.quad_cds,\n            name=\"match_quad\",\n            color=\"#696969\",\n            alpha=0.5,\n        )\n        q.visible = False\n        l = ts_plot.line(x=\"index\", y=\"y\", source=self.ts_cds, color=color)\n        ts_plot.x_range = Range1d(\n            0, max(self.df[\"index\"]), bounds=(0, max(self.df[\"x\"]))\n        )\n        ts_plot.y_range = Range1d(0, max(self.df[\"y\"]), bounds=(0, max(self.df[\"y\"])))\n\n        c = ts_plot.circle(\n            x=\"index\", y=\"y\", source=self.circle_cds, size=0, line_color=\"white\"\n        )\n        c.selection_glyph = Circle(line_color=\"white\")\n        c.nonselection_glyph = Circle(line_color=\"white\")\n\n        return ts_plot\n\n    def get_dist_dict(self, df, pattern_idx=0):\n        dist = df[\"distance\"]\n        max_dist = dist.max()\n        min_dist = dist.min()\n        x_offset = self.df.shape[0] - self.window / 2\n        y_offset = max_dist / 2\n        distance = dist.loc[pattern_idx]\n        text = distance.round(1).astype(str)\n        gauge_dict = dict(x=[0 + x_offset], y=[0 + y_offset], text=[text])\n\n        return gauge_dict\n\n    def get_mp_plot(self):\n        \"\"\"\n        Matrix Profile Plot\n        \"\"\"\n        mp_plot = figure(\n            x_range=self.ts_plot.x_range,\n            toolbar_location=None,\n            sizing_mode=self.sizing_mode,\n            title=\"Matrix Profile (All Minimum Distances)\",\n        )\n        q = mp_plot.quad(\n            \"vert_line_left\",\n            \"vert_line_right\",\n            \"vert_line_top\",\n            \"vert_line_bottom\",\n            source=self.quad_cds,\n            name=\"pattern_start\",\n            color=\"#54b847\",\n        )\n        q.visible = False\n        q = mp_plot.quad(\n            \"hori_line_left\",\n            \"hori_line_right\",\n            \"hori_line_top\",\n            \"hori_line_bottom\",\n            source=self.quad_cds,\n            name=\"match_dist\",\n            color=\"#696969\",\n            alpha=0.5,\n        )\n        q.visible = False\n        mp_plot.line(x=\"index\", y=\"distance\", source=self.ts_cds, color=\"black\")\n        # mp_plot.x_range = Range1d(0, self.df.shape[0]-self.window+1, bounds=(0, self.df.shape[0]-self.window+1))\n        mp_plot.x_range = Range1d(\n            0, self.df.shape[0] + 1, bounds=(0, self.df.shape[0] + 1)\n        )\n        mp_plot.y_range = Range1d(\n            0, max(self.df[\"distance\"]), bounds=(0, max(self.df[\"distance\"]))\n        )\n\n        label = LabelSet(\n            x=\"x\",\n            y=\"y\",\n            text=\"text\",\n            source=self.dist_cds,\n            text_align=\"center\",\n            name=\"gauge_label\",\n            text_color=\"black\",\n            text_font_size=\"30pt\",\n        )\n        mp_plot.add_layout(label)\n\n        return mp_plot\n\n    def get_pm_plot(self):\n        \"\"\"\n        Pattern-Match Plot\n        \"\"\"\n        pm_plot = figure(\n            toolbar_location=None,\n            sizing_mode=self.sizing_mode,\n            title=\"Pattern Match Overlay\",\n        )\n        l = pm_plot.line(\n            \"index\",\n            \"pattern\",\n            source=self.pattern_match_cds,\n            name=\"pattern_line\",\n            color=\"#54b847\",\n            line_width=2,\n        )\n        l.visible = False\n        l = pm_plot.line(\n            \"index\",\n            \"match\",\n            source=self.pattern_match_cds,\n            name=\"match_line\",\n            color=\"#696969\",\n            alpha=0.5,\n            line_width=2,\n        )\n        l.visible = False\n\n        return pm_plot\n\n    def get_logo_div(self):\n        \"\"\"\n        STUMPY logo\n        \"\"\"\n\n        logo_div = Div(\n            text=\"&lt;a href='https://stumpy.readthedocs.io/en/latest/'&gt;&lt;img src='https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/images/stumpy_logo_small.png' style='width:100%'&gt;&lt;/a&gt;\", sizing_mode=\"stretch_width\"\n        )\n\n        return logo_div\n\n    def get_heroku_div(self):\n        \"\"\"\n        STUMPY Heroku App Link\n        \"\"\"\n\n        heroku_div = Div(text=\"http://tiny.cc/stumpy-demo\")\n\n        return heroku_div\n\n    def get_slider(self, value=0):\n        slider = Slider(\n            start=0.0,\n            end=max(self.df[\"index\"]) - self.window,\n            value=value,\n            step=1,\n            title=\"Subsequence\",\n            sizing_mode=self.sizing_mode,\n        )\n        return slider\n\n    def get_play_button(self):\n        play_btn = Button(label=\"► Play\")\n        play_btn.on_click(self.animate)\n        return play_btn\n\n    def get_text_input(self):\n        txt_inp = TextInput(sizing_mode=self.sizing_mode)\n        return txt_inp\n\n    def get_buttons(self):\n        pattern_btn = Button(label=\"Show Motif\", sizing_mode=self.sizing_mode)\n        match_btn = Button(label=\"Show Nearest Neighbor\", sizing_mode=self.sizing_mode)\n        reset_btn = Button(label=\"Reset\", sizing_mode=self.sizing_mode, button_type=\"primary\")\n        return pattern_btn, match_btn, reset_btn\n\n    def update_plots(self, attr, new, old):\n        self.quad_cds.data = self.get_quad_dict(self.df, self.slider.value)\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, self.slider.value\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, self.slider.value)\n\n    def custom_update_plots(self, attr, new, old):\n        self.quad_cds.data = self.get_custom_quad_dict(\n            self.df, self.pattern_idx, self.slider.value\n        )\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, self.pattern_idx, self.slider.value\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, self.slider.value)\n        dist = self.df[\"distance\"].loc[self.slider.value]\n\n    def show_hide_pattern(self):\n        pattern_quad = self.ts_plot.select(name=\"pattern_quad\")[0]\n        pattern_start = self.mp_plot.select(name=\"pattern_start\")[0]\n        pattern_line = self.pm_plot.select(name=\"pattern_line\")[0]\n        if pattern_quad.visible:\n            pattern_start.visible = False\n            pattern_line.visible = False\n            pattern_quad.visible = False\n            self.pattern_btn.label = \"Show Motif\"\n        else:\n            pattern_start.visible = True\n            pattern_line.visible = True\n            pattern_quad.visible = True\n            self.pattern_btn.label = \"Hide Motif\"\n\n    def show_hide_match(self):\n        match_quad = self.ts_plot.select(name=\"match_quad\")[0]\n        match_dist = self.mp_plot.select(name=\"match_dist\")[0]\n        match_line = self.pm_plot.select(name=\"match_line\")[0]\n        if match_quad.visible:\n            match_dist.visible = False\n            match_line.visible = False\n            match_quad.visible = False\n            self.match_btn.label = \"Show Nearest Neighbor\"\n        else:\n            match_dist.visible = True\n            match_line.visible = True\n            match_quad.visible = True\n            self.match_btn.label = \"Hide Nearest Neighbor\"\n\n    def update_slider(self, attr, old, new):\n        self.slider.value = int(self.txt_inp.value)\n\n    def animate(self):\n        if self.play_btn.label == \"► Play\":\n            self.play_btn.label = \"❚❚ Pause\"\n            self.animation.start()\n        else:\n            self.play_btn.label = \"► Play\"\n            self.animation.stop()\n\n    def update_animate(self, shift=50):\n        if self.window &lt; self.m:  # Probably using box select\n            start = self.slider.value\n            end = start + shift\n            if self.df.loc[start:end, \"distance\"].min() &lt;= 15:\n                self.slider.value = self.df.loc[start:end, \"distance\"].idxmin()\n                self.animate()\n            elif self.slider.value + shift &lt;= self.slider.end:\n                self.slider.value = self.slider.value + shift\n            else:\n                self.slider.value = 0\n        elif self.slider.value + shift &lt;= self.slider.end:\n            self.slider.value = self.slider.value + shift\n        else:\n            self.slider.value = 0\n\n    def reset(self):\n        self.sizing_mode = \"stretch_both\"\n        self.window = self.m\n\n        self.default_idx = self.min_distance_idx\n        self.df = self.get_df_from_file()\n        self.ts_cds.data = self.get_ts_dict(self.df)\n        self.mp_plot.y_range.end = max(self.df[\"distance\"])\n        self.mp_plot.title.text = \"Matrix Profile (All Minimum Distances)\"\n        self.mp_plot.y_range.bounds = (0, max(self.df[\"distance\"]))\n        self.quad_cds.data = self.get_quad_dict(self.df, pattern_idx=self.default_idx)\n        self.pattern_match_cds.data = self.get_pattern_match_dict(\n            self.df, pattern_idx=self.default_idx\n        )\n        self.dist_cds.data = self.get_dist_dict(self.df, pattern_idx=self.default_idx)\n        self.circle_cds.data = self.get_circle_dict(self.df)\n        # Remove callback and add old callback\n        if self.custom_update_plots in self.slider._callbacks[\"value\"]:\n            self.slider.remove_on_change(\"value\", self.custom_update_plots)\n            self.slider.on_change(\"value\", self.update_plots)\n        self.slider.end = self.df.shape[0] - self.window\n        self.slider.value = self.default_idx\n\n    def get_data(self):\n        self.df = self.get_df_from_file()\n        self.default_idx = self.min_distance_idx\n        self.ts_cds = ColumnDataSource(self.get_ts_dict(self.df))\n        self.quad_cds = ColumnDataSource(\n            self.get_quad_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.pattern_match_cds = ColumnDataSource(\n            self.get_pattern_match_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.dist_cds = ColumnDataSource(\n            self.get_dist_dict(self.df, pattern_idx=self.default_idx)\n        )\n        self.circle_cds = ColumnDataSource(self.get_circle_dict(self.df))\n\n    def get_plots(self, ts_plot_color=\"black\"):\n        self.ts_plot = self.get_ts_plot(color=ts_plot_color)\n        self.mp_plot = self.get_mp_plot()\n        self.pm_plot = self.get_pm_plot()\n\n    def get_widgets(self):\n        self.slider = self.get_slider(value=self.default_idx)\n        self.play_btn = self.get_play_button()\n        self.txt_inp = self.get_text_input()\n        self.pattern_btn, self.match_btn, self.reset_btn = self.get_buttons()\n        self.logo_div = self.get_logo_div()\n        self.heroku_div = self.get_heroku_div()\n\n    def set_callbacks(self):\n        self.slider.on_change(\"value\", self.update_plots)\n        self.pattern_btn.on_click(self.show_hide_pattern)\n        self.show_hide_pattern()\n        self.match_btn.on_click(self.show_hide_match)\n        self.show_hide_match()\n        self.reset_btn.on_click(self.reset)\n        self.txt_inp.on_change(\"value\", self.update_slider)\n\n    def get_layout(self):\n        self.get_data()\n        self.get_plots()\n        self.get_widgets()\n        self.set_callbacks()\n\n        l = layout(\n            [\n                [self.ts_plot],\n                [self.mp_plot],\n                [self.pm_plot],\n                [self.slider],\n                [self.pattern_btn, self.match_btn, self.play_btn, self.logo_div],\n            ],\n            sizing_mode=self.sizing_mode,\n        )\n\n        return l\n\n    def get_raw_layout(self):\n        self.get_data()\n        self.get_plots(ts_plot_color=\"#54b847\")\n\n        l = layout([[self.ts_plot], [self.mp_plot]], sizing_mode=self.sizing_mode)\n\n        return l\n\n\ndashboard = StumpyBokehDashboard()\n\ndef get_components(dashboard: StumpyBokehDashboard=dashboard):\n    dashboard.get_data()\n    dashboard.get_plots()\n    dashboard.get_widgets()\n    dashboard.set_callbacks()\n\n    logo = dashboard.logo_div\n    settings = layout(\n        dashboard.pattern_btn,\n        dashboard.match_btn,\n        dashboard.play_btn,\n        dashboard.slider,\n        height=150,\n        sizing_mode=\"stretch_width\",\n    )\n    main = layout(\n        [\n            [dashboard.ts_plot],\n            [dashboard.mp_plot],\n            [dashboard.pm_plot],\n        ],\n        sizing_mode=dashboard.sizing_mode,\n    )\n    return logo, settings, main\n\npn.extension(template=\"fast\")\npn.state.template.param.update(\n    site_url=\"https://awesome-panel.org\",\n    site=\"Awesome Panel\",\n    title=\"Stumpy Timeseries Analysis\",\n    favicon=\"https://raw.githubusercontent.com/MarcSkovMadsen/awesome-panel-assets/320297ccb92773da099f6b97d267cc0433b67c23/favicon/ap-1f77b4.ico\",\n    header_background=\"#459db9\",\n    theme_toggle=False,\n)\n\nlogo, settings, main = get_components()\n\npn.Column(\n    logo,\n    settings, sizing_mode=\"stretch_width\",\n).servable(target=\"sidebar\")\npn.panel(main, sizing_mode=\"stretch_both\", max_height=800).servable(target=\"main\")\n\nDownload (right-click, save-as)"
  },
  {
    "objectID": "resources/stumpy/index.html#gif",
    "href": "resources/stumpy/index.html#gif",
    "title": "Stumpy",
    "section": "Gif",
    "text": "Gif\nI think the app looks amazing. Its really performant too."
  },
  {
    "objectID": "resources/stumpy/index.html#mp4",
    "href": "resources/stumpy/index.html#mp4",
    "title": "Stumpy",
    "section": "Mp4",
    "text": "Mp4\n\n\nYour browser does not support HTML video."
  },
  {
    "objectID": "resources/stumpy/index.html#png",
    "href": "resources/stumpy/index.html#png",
    "title": "Stumpy",
    "section": "Png",
    "text": "Png"
  },
  {
    "objectID": "resources/stumpy/index.html#social",
    "href": "resources/stumpy/index.html#social",
    "title": "Stumpy",
    "section": "Social",
    "text": "Social\nPlease share on social media. Thanks."
  }
]